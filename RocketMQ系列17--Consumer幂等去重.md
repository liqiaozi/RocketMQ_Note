---
title:  RocketMQ系列17--Consumer幂等去重
date:  2018-09-09
categories:  RocketMQ 
tags: [rocketmq,幂等性,去重] 
	 
---


# 1. 幂等性 #

 ## 1.1 什么是幂等性 ##

>  它是一种数学上的概念，使f(x)=f(f(x))能够成立的数学性质。用再编程领域，则意为对同一个系统，使用同一样的条件，一次请求和重复的多次请求对系统资源的影响是一致的。



> 幂等性是分布式系统设计中十分重要的概念，具有这一性质的接口再设计时总是坚持这样的一种理念:调用接口发生异常并且重复尝试时，总是会造成系统无法承受的损失。所以必须阻止这种现象的发生。

> 幂等有2个维度：一是空间维度上的幂等，即幂等对象的范围，是个人还是机构，是某一次交易还是某种类型的交易...二是时间维度上的幂等，即幂等的保证时间，是几秒、几分钟还是永久性的...


 ## 1.2 幂等适用领域 ##

试想这样的一种场景：在电商平台上支付后，因为网络原因导致系统提示你支付失败，于是你又重新付款了一次，等完成后检查网银发现被系统扣了两次款，这是一种什么样的体验？

造成上述问题的原因可能有很多，比如第一次付款时实际支付成功，但是信息返回时网络中断导致系统误判；又比如第一次付款的确失败了，但第二次付款时发生意外，导致支付请求被重复发送等等。在一次支付的过程中，每个环节都有可能会发生问题，我们要如何规避这类问题引发的分险？

幂等性是解决这类问题的方案之一，所以在电商，银行，互联网金融等对数据准确性要求很高的领域中，这一特性具有十分重要的地位。



 ## 1.3 幂等的思路 ##

**1. MVCC**
多版本并发控制，乐观锁的一种实现，再数据更新时需要去比较持有数据的版本号，版本号不一致的操作无法成功，例如博客的点在次数自动+1d的接口：

```
boolean addCount(Long id,Long version);

update blogTable set count = count + 1,version = version + 1 where id = 123 and version = 123;
```
每一个version只有一次执行成功的机会，一旦失败必须重新获取。

**2. 去重表**

利用数据库表单的特性来实现幂等性，常用思路:在表上构建唯一性索引，保证某一类数据一旦执行完毕，后续同样的请求再也无法成功写入。

**3. Token机制**

核心思想：为每一次操作生成一个唯一的凭证，也就是token。一个token在操作的每一个阶段只有一次执行权，一旦执行成功则保存执行结果。对重复的请求，返回同一个结果。

以电商平台为例子，电商平台上的订单id就是最适合的token。当用户下单时，会经历多个环节，比如生成订单，减库存，减优惠券等等。

每一个环节执行时都先检测一下该订单id是否已经执行过这一步骤，对未执行的请求，执行操作并缓存结果，而对已经执行过的id，则直接返回之前的执行结果，不做任何操作。这样可以在最大程度上避免操作的重复执行问题，缓存起来的执行结果也能用于事务的控制等。

# 2. 消息重复及去重 #
RocketMQ是怎样解决消息重复的问题呢？还是“恰好”不解决。

造成消息重复的根本原因是：网络不可达。只要通过网络交换数据，就无法避免这个问题。所以解决这个问题的办法就是绕过这个问题。那么问题就变成了：如果消费端收到两条一样的消息，应该怎样处理？
- 消费端处理消息的业务逻辑保持幂等性
- 保证每条消息都有唯一编号且保证消息处理成功与去重表的日志同时出现

第1条很好理解，只要保持幂等性，不管来多少条重复消息，最后处理的结果都一样。

第2条原理就是利用一张日志表来记录已经处理成功的消息的ID，如果新到的消息ID已经在日志表中，那么就不再处理这条消息。

第1条解决方案，很明显应该在消费端实现，不属于消息系统要实现的功能。

第2条可以消息系统实现，也可以业务端实现。正常情况下出现重复消息的概率其实很小，如果由消息系统来实现的话，肯定会对消息系统的吞吐量和高可用有影响，所以最好还是由业务端自己处理消息重复的问题，这也是RocketMQ不解决消息重复的问题的原因。

RocketMQ不保证消息不重复，如果你的业务需要保证严格的不重复消息，需要你自己在业务端去重。

还有一种 **高并发下去重**

> 采用Redis去重（key天然支持原子性并要求不可重复），但是由于不在一个事务，要求有适当的补偿策略

> 利用redis事务，主键（我们必须把全量的操作数据都存放在redis里，然后定时去和数据库做数据同步）—-即消费处理后，该处理本来应该保存在数据库的，先保存在redis，利用redis和关系型数据库一起做去重机制



> 拿到这个消息做redis的set的操作.redis就是天然幂等性。
> 准备一个第三方介质,来做消费记录。以redis为例，给消息分配一个全局id，只要消费过该消息，将 < id,message>以K-V形式写入redis。那消费者开始消费前，先去redis中查询有没消费记录即可。



# 3. 推荐 #

【1】[幂等性，RocketMQ解决消息顺序和重复，Mysql与Java中的乐观锁悲观锁](https://blog.csdn.net/yzhou86/article/details/79156458)